if ( SERVER ) then	AddCSLuaFile( "shared.lua" )else	SWEP.PrintName			= "Force Lightning"	SWEP.Author				= "SweptThrone"	SWEP.Slot				= 2	SWEP.SlotPos			= 3endSWEP.Base					= "weapon_swsft_base"SWEP.Category				= "Throneco StarWars"SWEP.Spawnable				= trueSWEP.AdminSpawnable			= trueSWEP.FireSound 			= "weapons/starwars/force_lightning1.wav"SWEP.Weight					= 5SWEP.AutoSwitchTo			= falseSWEP.AutoSwitchFrom			= falseSWEP.Primary.Recoil			= 2.5SWEP.Primary.Damage			= 50SWEP.Primary.NumShots		= 1SWEP.Primary.Cone			= 0.010SWEP.Primary.ClipSize		= -1SWEP.Primary.Delay			= 0.10SWEP.Primary.DefaultClip	= -1SWEP.Primary.Automatic		= trueSWEP.Primary.Ammo			= "none"SWEP.Primary.Tracer 		= "effect_sw_laser_blue"SWEP.Secondary.Automatic	= trueSWEP.Secondary.Ammo			= "none"SWEP.Secondary.Delay = .1SWEP.HoldType = "duel"SWEP.ViewModelFOV = 90SWEP.ViewModelFlip = falseSWEP.UseHands = trueSWEP.ViewModel = "models/weapons/c_357.mdl"SWEP.WorldModel = "models/weapons/w_pistol.mdl"SWEP.ShowViewModel = trueSWEP.ShowWorldModel = falseSWEP.ViewModelBoneMods = {	["ValveBiped.Bip01_R_Finger31"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 18.75, 0) },	["Bullet3"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },	["ValveBiped.Bip01_R_Finger11"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0.03, 0.09), angle = Angle(-1.208, -21.73, 12.937) },	["Bullet6"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-25, 20, 0) },	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 5, 0) },	["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-50, -95, 150) },	["ValveBiped.Bip01_R_Finger32"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 20.068, 0) },	["ValveBiped.Bip01_R_Finger42"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 51.05, 0) },	["Python"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },	["ValveBiped.Bip01_R_Finger01"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -25, 0) },	["ValveBiped.Bip01_R_Finger41"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 9.807, 0) },	["Bullet1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(41.911, 44.84, 23.868) },	["Bullet4"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },	["ValveBiped.Bip01_R_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(12.008, 16.745, 0) },	["ValveBiped.Bip01_R_Finger21"] = { scale = Vector(0.933, 0.933, 0.933), pos = Vector(0, 0, 0), angle = Angle(-5.646, 21.253, 0) },	["ValveBiped.Bip01_R_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(-0.21, 0, 0), angle = Angle(-30, 38.041, 0) },	["ValveBiped.Bip01_R_Finger02"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -20, 0) },	["Cylinder"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },	["Bullet5"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },	["ValveBiped.Bip01_R_Finger22"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 27.802, 0) },	["ValveBiped.Bip01_R_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0.505, 58.675, 0) },	["Cylinder_release"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },	["Bullet2"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },	["ValveBiped.Bip01_R_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(-0.26, -0.152, 0), angle = Angle(-18.764, 51.015, -14.695) },	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 0, -70) }}SWEP.VElements = {    ["muzzleflare2"] = { type = "Sprite", sprite = "effects/electric1", bone = "ValveBiped.Bip01_L_Clavicle", rel = "muzzleflare", pos = Vector(0, 0, 10.923), angle = Angle(0,0,0), size = { x = 16, y = 16 }, color = Color(0, 85, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},    ["muzzleflare3"] = { type = "Sprite", sprite = "effects/electric1", bone = "ValveBiped.Bip01_L_Clavicle", rel = "muzzleflare", pos = Vector(0, 0, 10.923), angle = Angle(0,0,0), size = { x = 15, y = 15 }, color = Color(0, 0, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},    ["muzzleflare"] = { type = "Sprite", sprite = "effects/rollerglow", bone = "ValveBiped.Bip01_L_Clavicle", rel = "body", pos = Vector(0, 0, 20.319), angle = Angle(0,0,0), size = { x = 14, y = 14 }, color = Color(84, 94, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},}SWEP.WElements = {    ["muzzleflare"] = { type = "Sprite", sprite = "effects/rollerglow", bone = "ValveBiped.Bip01_R_Hand", rel = "body", pos = Vector(0, 0, 20.319), angle = Angle(0,0,0), size = { x = 14, y = 14 }, color = Color(0, 0, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},    ["muzzleflare2"] = { type = "Sprite", sprite = "effects/electric1", bone = "ValveBiped.Bip01_R_Hand", rel = "muzzleflare", pos = Vector(0, 0, -0.245), angle = Angle(0,0,0), size = { x = 16, y = 16 }, color = Color(0, 0, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},    ["muzzleflare3"] = { type = "Sprite", sprite = "effects/electric1", bone = "ValveBiped.Bip01_R_Hand", rel = "muzzleflare", pos = Vector(0, 0, -0.245), angle = Angle(0,0,0), size = { x = 15, y = 15 }, color = Color(0, 0, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}}function OverTheShoulder( ply, pos, angles, fov )	if !ply:IsValid() then return end	if !ply:GetActiveWeapon():IsValid() then return end	if ply:GetActiveWeapon():GetClass() == "st_forcelightning" then		local view = {}		view.origin = pos-( angles:Forward()*35 + angles:Right()*-20 )		view.angles = angles		view.fov = fov		view.drawviewer = true		return view	endendfunction ReturnToNormal( ply, pos, angles, fov )	local view = {}	view.origin = angles:Zero()	view.angles = angles	view.fov = fov	view.drawviewer = true	return viewendhook.Add( "CalcView", "FLThirdPerson", OverTheShoulder )function SWEP:Reload()endfunction SWEP:SelectTargets( num, dist )	local t = {}	dist = dist or 512	local p = {}	for id, ply in pairs( ents.GetAll() ) do		if ( !ply:GetModel() || ply:GetModel() == "" || ply == self.Owner || ply:Health() < 1 ) then continue end		if ply.PlayerTeam then			if players_only then continue end 			if not friends and ply.PlayerTeam == self.Owner:Team() then 				continue			elseif friends and ply.PlayerTeam != self.Owner:Team() then 				continue 			end		end		if ply.Team then			if not friends and ply:Team() == self.Owner:Team() then				continue			elseif friends and ply:Team() != self.Owner:Team() then				continue 			end		end		if ( string.StartWith( ply:GetModel() || "", "models/gibs/" ) ) then continue end		if ( string.find( ply:GetModel() || "", "chunk" ) ) then continue end		if ( string.find( ply:GetModel() || "", "_shard" ) ) then continue end		if ( string.find( ply:GetModel() || "", "_splinters" ) ) then continue end		local tr = util.TraceLine( {			start = self.Owner:GetShootPos(),			endpos = (ply.GetShootPos && ply:GetShootPos() || ply:GetPos()),			filter = function(ent) return ent == ply or not ent.Nick end		} )		if not IsValid( tr.Entity ) or tr.Entity != ply or tr.Entity == game.GetWorld() then continue end		local spos = self.Owner:GetShootPos()		local pos1 = self.Owner:GetPos() + self.Owner:GetAimVector() * dist		local pos2 = tr.HitPos		local dot = self.Owner:GetAimVector():Dot( ( pos2 - self.Owner:GetShootPos() ):GetNormalized() )		local dist2 = spos:Distance( pos2 )		if ( dist2 <= dist && ply:EntIndex() > 0 && ply:GetModel() && ply:GetModel() != "" ) then			table.insert( p, { ply = ply, dist = dist2, dot = dot, score = dot + ( ( dist - dist2 ) / dist ) * 50 } )		end	end	local d = {}	for id, ply in SortedPairsByMemberValue( p, "dist" ) do		table.insert( t, ply.ply )		d[ply.ply] = ply		if ( #t >= num ) then break end	end	local f = {}	for i = 1,num do		f[i] = t[i]	end	return f,dendsound.Add( {	name = "lighting_hands",	channel = CHAN_WEAPON,	volume = 1.0,	level = 100,	pitch = 100,	sound = "weapons/starwars/force_lightning1.wav"} )sound.Add( {	name = "hand_zap",	channel = CHAN_WEAPON,	volume = 1.0,	level = 100,	pitch = 100,	sound = "weapons/starwars/force_lightning2.wav"} )local dist = 800function SWEP:Think()		self.BaseClass.Think(self)	self.VElements["muzzleflare"].color.a = math.max(0,self.VElements["muzzleflare"].color.a - 10 * FrameTime() * 60)	self.VElements["muzzleflare"].size.x = math.max(0,self.VElements["muzzleflare"].size.x - 0.5 * FrameTime() * 60)	self.VElements["muzzleflare"].size.y = math.max(0,self.VElements["muzzleflare"].size.y - 0.5 * FrameTime() * 60)	self.VElements["muzzleflare2"].color.a = math.max(0,self.VElements["muzzleflare2"].color.a - 10 * FrameTime() * 60)	self.VElements["muzzleflare3"].color.a = math.max(0,self.VElements["muzzleflare3"].color.a - 10 * FrameTime() * 60)	self.WElements["muzzleflare"].color.a = math.max(0,self.WElements["muzzleflare"].color.a - 10 * FrameTime() * 60)	self.WElements["muzzleflare"].color.a = math.max(0,self.WElements["muzzleflare"].color.b - 10 * FrameTime() * 60)	self.WElements["muzzleflare"].size.x = math.max(0,self.WElements["muzzleflare"].size.x - 0.5 * FrameTime() * 60)	self.WElements["muzzleflare"].size.y = math.max(0,self.WElements["muzzleflare"].size.y - 0.5 * FrameTime() * 60)	self.WElements["muzzleflare2"].color.a = math.max(0,self.WElements["muzzleflare2"].color.a - 10 * FrameTime() * 60)	self.WElements["muzzleflare3"].color.a = math.max(0,self.WElements["muzzleflare3"].color.a - 10 * FrameTime() * 60)endfunction SWEP:PrimaryAttack()	if self.Owner:HasGodMode() == true then return end		if IsFirstTimePredicted() then			self.VElements["muzzleflare"].size.x = 20		self.VElements["muzzleflare"].size.y = 20		self.VElements["muzzleflare"].color.a = 255		self.VElements["muzzleflare2"].color.a = 255		self.VElements["muzzleflare3"].color.a = 255		self.WElements["muzzleflare"].size.x = 20		self.WElements["muzzleflare"].size.y = 20		self.WElements["muzzleflare"].color.a = 255		self.WElements["muzzleflare2"].color.a = 255		self.WElements["muzzleflare3"].color.a = 255	end	if SERVER then		local firedtime = 0		local targ,tab = self:SelectTargets(5,dist)		for k,v in pairs(targ) do			if tab[v].dot < 0.8 then continue end				local dmg = DamageInfo()				dmg:SetAttacker( self.Owner || self )				dmg:SetInflictor( self or self.Owner )				dmg:SetDamage( FrameTime() * 1333 )				v:TakeDamageInfo( dmg )			end			local ed = EffectData()			ed:SetEntity(self)			ed:SetAttachment(1)			ed:SetStart( self.Owner:GetPos() + Vector(0,0,30) )			ed:SetOrigin( self.Owner:GetPos() + Vector(0,0,30) + self.Owner:GetForward() * math.random(dist - 50,dist + 50) + self.Owner:GetRight() * math.random(-80,80) + self.Owner:GetUp() * math.random(-20,20))			ed:SetFlags(0x0002)			util.Effect( "effect_arc_tracer", ed, true, true )		end	if ( self.Owner:IsNPC() ) then return end	self.Owner:ViewPunch( Angle( math.Rand(-0.2,-0.1) * self.Primary.Recoil, math.Rand(-0.1,0.1) * self.Primary.Recoil, 0 ) )	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)endfunction SWEP:SecondaryAttack()	if self.Owner:HasGodMode() == true then return end	if IsFirstTimePredicted() then		self.VElements["muzzleflare"].size.x = 20		self.VElements["muzzleflare"].size.y = 20		self.VElements["muzzleflare"].color.a = 255		self.VElements["muzzleflare2"].color.a = 255		self.VElements["muzzleflare3"].color.a = 255		self.WElements["muzzleflare"].size.x = 20		self.WElements["muzzleflare"].size.y = 20		self.WElements["muzzleflare"].color.a = 255		self.WElements["muzzleflare2"].color.a = 255		self.WElements["muzzleflare3"].color.a = 255	end	if SERVER then		local firedtime = 0		local targ,tab = self:SelectTargets(5,dist)		for k,v in pairs(targ) do			if tab[v].dot < 0.8 then continue end				local dmg = DamageInfo()				dmg:SetAttacker( self.Owner || self )				dmg:SetInflictor( self or self.Owner )				dmg:SetDamage( FrameTime() * 1333 )				v:TakeDamageInfo( dmg )			end			local ed = EffectData()			ed:SetEntity(self)			ed:SetAttachment(1)			ed:SetStart( self.Owner:GetPos() + Vector(0,0,30) )			ed:SetOrigin( self.Owner:GetPos() + Vector(0,0,30) + self.Owner:GetForward() * math.random(dist - 50,dist + 50) + self.Owner:GetRight() * math.random(-80,80) + self.Owner:GetUp() * math.random(-20,20))			ed:SetFlags(0x0002)			util.Effect( "effect_arc_tracer", ed, true, true )		end	if ( self.Owner:IsNPC() ) then return end	self.Owner:ViewPunch( Angle( math.Rand(-0.2,-0.1) * self.Primary.Recoil, math.Rand(-0.1,0.1) * self.Primary.Recoil, 0 ) )	self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)endfunction SWEP:Initialize()	self.BaseClass.Initialize(self)	if CLIENT then		self:SendWeaponAnim(ACT_DO_NOT_DISTURB)		self.VElements = table.FullCopy( self.VElements )		self.WElements = table.FullCopy( self.WElements )		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )		self:CreateModels(self.VElements)		self:CreateModels(self.WElements)		if IsValid(self.Owner) then			local vm = self.Owner:GetViewModel()			if IsValid(vm) then				self:ResetBonePositions(vm)				if (self.ShowViewModel == nil or self.ShowViewModel) then					vm:SetColor(Color(255,255,255,255))				else					vm:SetColor(Color(255,255,255,1))					vm:SetMaterial("Debug/hsv")							end			end		end	endendfunction SWEP:Holster()	self.BaseClass.Holster(self)	if CLIENT and IsValid(self.Owner) then		local vm = self.Owner:GetViewModel()		if IsValid(vm) then			self:ResetBonePositions(vm)		end	end	if CLIENT then return end	self.Owner:GodDisable()	print("[FL] God disabled because the weapon was switched...")	return trueendfunction SWEP:OnRemove()	self.BaseClass.OnRemove(self)	if CLIENT and IsValid(self.Owner) then		local vm = self.Owner:GetViewModel()		if IsValid(vm) then			self:ResetBonePositions(vm)		end	endendif CLIENT then	SWEP.vRenderOrder = nil	function SWEP:ViewModelDrawn()		local vm = self.Owner:GetViewModel()		if !IsValid(vm) then return end		vm:GetAttachment(1)		if (!self.VElements) then return end		self:UpdateBonePositions(vm)		if (!self.vRenderOrder) then			self.vRenderOrder = {}			for k, v in pairs( self.VElements ) do				if (v.type == "Model") then					table.insert(self.vRenderOrder, 1, k)				elseif (v.type == "Sprite" or v.type == "Quad") then					table.insert(self.vRenderOrder, k)				end			end					end		for k, name in ipairs( self.vRenderOrder ) do					local v = self.VElements[name]			if (!v) then self.vRenderOrder = nil break end			if (v.hide) then continue end						local model = v.modelEnt			local sprite = v.spriteMaterial						if (!v.bone) then continue end						local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )						if (!pos) then continue end						if (v.type == "Model" and IsValid(model)) then				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )				ang:RotateAroundAxis(ang:Up(), v.angle.y)				ang:RotateAroundAxis(ang:Right(), v.angle.p)				ang:RotateAroundAxis(ang:Forward(), v.angle.r)				model:SetAngles(ang)				//model:SetModelScale(v.size)				local matrix = Matrix()				matrix:Scale(v.size)				model:EnableMatrix( "RenderMultiply", matrix )								if (v.material == "") then					model:SetMaterial("")				elseif (model:GetMaterial() != v.material) then					model:SetMaterial( v.material )				end								if (v.skin and v.skin != model:GetSkin()) then					model:SetSkin(v.skin)				end								if (v.bodygroup) then					for k, v in pairs( v.bodygroup ) do						if (model:GetBodygroup(k) != v) then							model:SetBodygroup(k, v)						end					end				end								if (v.surpresslightning) then					render.SuppressEngineLighting(true)				end								render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)				render.SetBlend(v.color.a/255)				model:DrawModel()				render.SetBlend(1)				render.SetColorModulation(1, 1, 1)								if (v.surpresslightning) then					render.SuppressEngineLighting(false)				end							elseif (v.type == "Sprite" and sprite) then				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z				render.SetMaterial(sprite)				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)			elseif (v.type == "Quad" and v.draw_func) then								local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z				ang:RotateAroundAxis(ang:Up(), v.angle.y)				ang:RotateAroundAxis(ang:Right(), v.angle.p)				ang:RotateAroundAxis(ang:Forward(), v.angle.r)								cam.Start3D2D(drawpos, ang, v.size)					v.draw_func( self )				cam.End3D2D()			end					end			end	SWEP.wRenderOrder = nil	function SWEP:DrawWorldModel()		if self.ShowWorldModel == nil or self.ShowWorldModel == true then			self:DrawModel()		end				if (!self.WElements) then return end				if (!self.wRenderOrder) then			self.wRenderOrder = {}			for k, v in pairs( self.WElements ) do				if (v.type == "Model") then					table.insert(self.wRenderOrder, 1, k)				elseif (v.type == "Sprite" or v.type == "Quad") then					table.insert(self.wRenderOrder, k)				end			end		end				if (IsValid(self.Owner)) then			bone_ent = self.Owner		else			// when the weapon is dropped			bone_ent = self		end				for k, name in pairs( self.wRenderOrder ) do					local v = self.WElements[name]			if (!v) then self.wRenderOrder = nil break end			if (v.hide) then continue end						local pos, ang						if (v.bone) then				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )			else				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )			end						if (!pos) then continue end						local model = v.modelEnt			local sprite = v.spriteMaterial						if (v.type == "Model" and IsValid(model)) then				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )				ang:RotateAroundAxis(ang:Up(), v.angle.y)				ang:RotateAroundAxis(ang:Right(), v.angle.p)				ang:RotateAroundAxis(ang:Forward(), v.angle.r)				model:SetAngles(ang)				//model:SetModelScale(v.size)				local matrix = Matrix()				matrix:Scale(v.size)				model:EnableMatrix( "RenderMultiply", matrix )								if (v.material == "") then					model:SetMaterial("")				elseif (model:GetMaterial() != v.material) then					model:SetMaterial( v.material )				end								if (v.skin and v.skin != model:GetSkin()) then					model:SetSkin(v.skin)				end								if (v.bodygroup) then					for k, v in pairs( v.bodygroup ) do						if (model:GetBodygroup(k) != v) then							model:SetBodygroup(k, v)						end					end				end								if (v.surpresslightning) then					render.SuppressEngineLighting(true)				end								render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)				render.SetBlend(v.color.a/255)				model:DrawModel()				render.SetBlend(1)				render.SetColorModulation(1, 1, 1)								if (v.surpresslightning) then					render.SuppressEngineLighting(false)				end							elseif (v.type == "Sprite" and sprite) then								local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z				render.SetMaterial(sprite)				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)							elseif (v.type == "Quad" and v.draw_func) then								local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z				ang:RotateAroundAxis(ang:Up(), v.angle.y)				ang:RotateAroundAxis(ang:Right(), v.angle.p)				ang:RotateAroundAxis(ang:Forward(), v.angle.r)								cam.Start3D2D(drawpos, ang, v.size)					v.draw_func( self )				cam.End3D2D()			end					end			end	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )				local bone, pos, ang		if (tab.rel and tab.rel != "") then						local v = basetab[tab.rel]						if (!v) then return end						// Technically, if there exists an element with the same name as a bone			// you can get in an infinite loop. Let's just hope nobody's that stupid.			pos, ang = self:GetBoneOrientation( basetab, v, ent )						if (!pos) then return end						pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z			v.angle = v.angle or Angle(0,0,0)			ang:RotateAroundAxis(ang:Up(), v.angle.y)			ang:RotateAroundAxis(ang:Right(), v.angle.p)			ang:RotateAroundAxis(ang:Forward(), v.angle.r)						else					bone = ent:LookupBone(bone_override or tab.bone)			if (!bone) then return end						pos, ang = Vector(0,0,0), Angle(0,0,0)			local m = ent:GetBoneMatrix(bone)			if (m) then				pos, ang = m:GetTranslation(), m:GetAngles()			end						if (IsValid(self.Owner) and self.Owner:IsPlayer() and 				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then				ang.r = -ang.r // Fixes mirrored models			end				end				return pos, ang	end	function SWEP:CreateModels( tab )		if (!tab) then return end		// Create the clientside models here because Garry says we can't do it in the render hook		for k, v in pairs( tab ) do			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then								v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)				if (IsValid(v.modelEnt)) then					v.modelEnt:SetPos(self:GetPos())					v.modelEnt:SetAngles(self:GetAngles())					v.modelEnt:SetParent(self)					v.modelEnt:SetNoDraw(true)					v.createdModel = v.model				else					v.modelEnt = nil				end							elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then								local name = v.sprite.."-"				local params = { ["$basetexture"] = v.sprite }				// make sure we create a unique name based on the selected options				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }				for i, j in pairs( tocheck ) do					if (v[j]) then						params["$"..j] = 1						name = name.."1"					else						name = name.."0"					end				end				v.createdSprite = v.sprite				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)							end		end			end		local allbones	local hasGarryFixedBoneScalingYet = false	function SWEP:UpdateBonePositions(vm)				if self.ViewModelBoneMods then						if (!vm:GetBoneCount()) then return end						// !! WORKAROUND !! //			// We need to check all model names :/			local loopthrough = self.ViewModelBoneMods			if (!hasGarryFixedBoneScalingYet) then				allbones = {}				for i=0, vm:GetBoneCount() do					local bonename = vm:GetBoneName(i)					if (self.ViewModelBoneMods[bonename]) then 						allbones[bonename] = self.ViewModelBoneMods[bonename]					else						allbones[bonename] = { 							scale = Vector(1,1,1),							pos = Vector(0,0,0),							angle = Angle(0,0,0)						}					end				end								loopthrough = allbones			end			// !! ----------- !! //						for k, v in pairs( loopthrough ) do				local bone = vm:LookupBone(k)				if (!bone) then continue end								// !! WORKAROUND !! //				local s = Vector(v.scale.x,v.scale.y,v.scale.z)				local p = Vector(v.pos.x,v.pos.y,v.pos.z)				local ms = Vector(1,1,1)				if (!hasGarryFixedBoneScalingYet) then					local cur = vm:GetBoneParent(bone)					while(cur >= 0) do						local pscale = loopthrough[vm:GetBoneName(cur)].scale						ms = ms * pscale						cur = vm:GetBoneParent(cur)					end				end								s = s * ms				// !! ----------- !! //								if vm:GetManipulateBoneScale(bone) != s then					vm:ManipulateBoneScale( bone, s )				end				if vm:GetManipulateBoneAngles(bone) != v.angle then					vm:ManipulateBoneAngles( bone, v.angle )				end				if vm:GetManipulateBonePosition(bone) != p then					vm:ManipulateBonePosition( bone, p )				end			end		else			self:ResetBonePositions(vm)		end		   	end	 	function SWEP:ResetBonePositions(vm)				if (!vm:GetBoneCount()) then return end		for i=0, vm:GetBoneCount() do			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )		end			end	/**************************		Global utility code	**************************/	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).	// Does not copy entities of course, only copies their reference.	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop	function table.FullCopy( tab )		if (!tab) then return nil end				local res = {}		for k, v in pairs( tab ) do			if (type(v) == "table") then				res[k] = table.FullCopy(v) // recursion ho!			elseif (type(v) == "Vector") then				res[k] = Vector(v.x, v.y, v.z)			elseif (type(v) == "Angle") then				res[k] = Angle(v.p, v.y, v.r)			else				res[k] = v			end		end				return res			end	end